#!/usr/bin/env python3

import asyncio
import random

from hashlib import sha1
from urllib.parse import urlencode

import bencode
import aiohttp


def open_raw_file(file_path):
    with open(file_path, 'rb') as file_object:
        file = file_object.read()
    return file


def make_tracker_params(raw_metafile):
    metafile_data = bencode.bdecode(raw_metafile)
    tracker_base_url = metafile_data[b'announce'].decode('utf-8')
    metafile_info = metafile_data[b'info']
    info_hash = make_info_hash(metafile_info)
    request_params = {
        'info_hash': info_hash,
        'peer_id': make_peer_id(),
        'port': 6881,
        'uploaded': 0,
        'downloaded': 0,
        'left': 0,
        'compact': 1,
        'event': 'started'
    }
    return tracker_base_url + '?' + urlencode(request_params)
    # info hash: urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file. Note that the value will be a bencoded dictionary, given the definition of the info key above.
    # peer_id: urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup. This is allowed to be any value, and may be binary data.
    # port: The port number that the client is listening on. Ports reserved for BitTorrent are typically 6881-6889. Clients may choose to give up if it cannot establish a port within this range.
    # uploaded: The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII. While not explicitly stated in the official specification, the concensus is that this should be the total number of bytes uploaded.
    # downloaded: The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten ASCII. While not explicitly stated in the official specification, the consensus is that this should be the total number of bytes downloaded.
    # left: The number of bytes this client still has to download in base ten ASCII. Clarification: The number of bytes needed to download to be 100% complete and get all the included files in the torrent.
    # compact: Setting this to 1 indicates that the client accepts a compact response.
    # event: If specified, must be one of started, completed, stopped, (or empty which is the same as not being specified). If not specified, then this request is one performed at regular intervals.


def make_info_hash(metafile_info):
    encoded = bencode.bencode(metafile_info)
    metafile_info_hash = sha1(encoded).digest()
    return metafile_info_hash


def make_peer_id():
    lead_string = '000000'
    random_digits = ''.join([str(random.randint(0, 9)) for _ in range(14)])
    return lead_string + random_digits


async def make_tracker_request(tracker_url):
    async with aiohttp.ClientSession() as session:
        async with session.get(tracker_url) as response:
            response_bytes = await response.read()
            response_dict = bencode.bdecode(response_bytes)
            return response_dict


def main():
    # setup
    torrent_file_path = 'test.torrent'
    loop = asyncio.get_event_loop()
    # tracker
    raw_metafile = open_raw_file(torrent_file_path)
    tracker_request_url = make_tracker_params(raw_metafile)
    tracker_task = loop.create_task(make_tracker_request(tracker_request_url))
    tracker_response = loop.run_until_complete(tracker_task)


if __name__ == '__main__':
    main()
